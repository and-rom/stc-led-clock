#
# generate_all
#
# Read three input data files and output LED segment patterns in code form that
#  is included in the source stream for compliation
#
# file1 format is "hexnum chars" where hexnum = hex entry index, char = "on" led segmemts
# file2 consists a index and a text string
# file3 is a template file for the output of the text strings
#
# file1 converts raw led segment letters to a translated hex number
# which is stored in an array with the characters hex number being the index
#
# file1:
#   0x30    abcdef
#   0x31    bc
#   0x32    abdeg
#   ... repeats for 127 chars total
#
# file2:
#
#    <41>  SEt,_
#    <42>  bEE,P
#
# Where <41> is the pattern used for matching in the output template file.
#  See the comments in the file "text_strings.txt" for explaination of the
#   special codes used to generate different character attributes
#
# file3:
#
#  #if DIGIT_3_FLIP
#      <4F1>
#      <4F2>
#
# The template file has <4F1> replaced with the hex code for string <41> with the character rotated
# (flipped) 180 degrees. In other locations, you will see the index markers:
#
#  #else
#      <4N1>
#      <4N2>
#
# Where the "N" character in the marker means do not flip or rotate the character pattern
# This is only needed in the third digit position due to lazy hardware engineers.
#
# The output from this GAW program thus becomes:
#
#  #if DIGIT_3_FLIP
#      0x92,0x86,0xB8,0xFF,       // SEt_
#      0x83,0x86,0xB0,0x8C,       // bEEP
#
# and lower in the listing:
#
#  #else
#      0x92,0x86,0x87,0xFF,       // SEt
#      0x83,0x86,0x86,0x8C,       // bEEP
#
# Note the difference in the value of the third hex number, this is
# the "flipped" LED segment pattern
#
BEGIN {

	while (getline <"segTable/segment_list.txt" > 0){

    if (match($0,/^#/)) # skip comment line
      continue

    if ( $2 == ";" ) {
      ledValueNorm[ hexToString($1 "") ] = "0xFF"
      ledValueFlip[ hexToString($1 "") ] = "0xFF"
    }
    if ( $2 ~ /[a-g]+/ ) {
      val  = 0;
      for ( i = 1; i <= length($2); i++) {
          c = substr($2,i,1)
          if ( c == "a" ) val += 1
          if ( c == "b" ) val += 2
          if ( c == "c" ) val += 4
          if ( c == "d" ) val += 8
          if ( c == "e" ) val += 16
          if ( c == "f" ) val += 32
          if ( c == "g" ) val += 64
          if ( c == "h" ) val += 128
      }
      s = ""
      if ( val >= 128 ){ s = s "1"; val -= 128 } else { s = s "0"}
      if ( val >=  64 ){ s = s "1"; val -=  64 } else { s = s "0"}
      if ( val >=  32 ){ s = s "1"; val -=  32 } else { s = s "0"}
      if ( val >=  16 ){ s = s "1"; val -=  16 } else { s = s "0"}
      if ( val >=   8 ){ s = s "1"; val -=   8 } else { s = s "0"}
      if ( val >=   4 ){ s = s "1"; val -=   4 } else { s = s "0"}
      if ( val >=   2 ){ s = s "1"; val -=   2 } else { s = s "0"}
      if ( val >=   1 ){ s = s "1"; val -=   1 } else { s = s "0"}

    	b01 = substr(s,8,1)         # get each bit in order
    	b02 = substr(s,7,1)
    	b04 = substr(s,6,1)
    	b08 = substr(s,5,1)
    	b10 = substr(s,4,1)
    	b20 = substr(s,3,1)
    	b40 = substr(s,2,1)
    	b80 = substr(s,1,1)
    	#
    	# the bit reorder is here:
      #
      # inverted logic here!
      #
      val = 0
      if ( b80 == "0" ){ val += 128 }
      if ( b40 == "0" ){ val +=  64 }
      if ( b20 == "0" ){ val +=  32 }
      if ( b10 == "0" ){ val +=  16 }
      if ( b08 == "0" ){ val +=   8 }
      if ( b04 == "0" ){ val +=   4 }
      if ( b02 == "0" ){ val +=   2 }
      if ( b01 == "0" ){ val +=   1 }
      ledValueNorm[ hexToString($1 "") ] = sprintf("0x%02X",val)
      #
      # inverted logic here!
      #
      val = 0
      if ( b80 == "0" ){ val += 128 }
      if ( b40 == "0" ){ val +=  64 }
      if ( b04 == "0" ){ val +=  32 }
      if ( b02 == "0" ){ val +=  16 }
      if ( b01 == "0" ){ val +=   8 }
      if ( b20 == "0" ){ val +=   4 }
      if ( b10 == "0" ){ val +=   2 }
      if ( b08 == "0" ){ val +=   1 }
      ledValueFlip[ hexToString($1 "") ] = sprintf("0x%02X",val)
      }
  } # end of file 1

	while (getline < "segTable/text_strings.txt" > 0) {

    if (match($0,/^#/)) # skip comment line
      continue

      if (NF == 2) {
        if ( match($1,/[0-9]+/) )
          text_string[substr($1,RSTART,RLENGTH)] = $2
    }
  } # end file text_strings.txt

  printf("// ----------------------------------------------------------------\n")
  printf("// ----------------------------------------------------------------\n")
  printf("// ------    This file was generated by the make process     ------\n")
  printf("// ------ Do not edit this file as your changes will be lost ------\n")
  printf("// ------     with the next invocation of \"make led\"         ------\n")
  printf("// ----------------------------------------------------------------\n")
  printf("// ----------------------------------------------------------------\n")

	while (getline < "segTable/codeTemplate.txt" > 0) {

    if (match($1,/<[234][NF][0-9]+>/)) {
      sIndex = $1
      gsub(/[<>]/,"",sIndex)
      gsub(/[NF]/,"",sIndex)
      orientation = substr($1,3,1)
      gen_string = text_string[sIndex]

      # handle decimal point in text string
      decimal_loc = index(gen_string,".")
      if ( decimal_loc ){
        # remove actual decimal from text
        decimal_loc--
        gsub(/\./,"",gen_string)
      }

      # handle flip character escaped code
      flip_loc = index(gen_string,",")
      if ( flip_loc ){
        # remove escape code from text
        flip_loc--
        gsub(/,/,"",gen_string)
      }

      rc = "" # start with empty string
      # now generate each character
      for (i =1; i <= length(gen_string); i++) {
        ci = substr(gen_string,i,1)

        if ( orientation == "F" && i == flip_loc )
          tc = ledValueFlip[ci]
         else
          tc = ledValueNorm[ci]

        # handle decimal point if at that character
        if (i == decimal_loc){
          tc = add_decimal(tc)
        }

      # now concatenate everything into one string each pass through
      rc = rc tc ","
      } #end for of each character

      # now replace placeholder with text
      gsub(/<[0-9][NF][0-9]+>/,rc)
      } # end if $1 matches pattern <2 3 or 4>

    if (match($1,/<[1][NF][0-9]+>/)) {
      # here when we have single "0-9" substitution
      sIndex = substr($1,4,1)
      orientation = substr($1,3,1)
      gen_string = text_string[sIndex]
      if ( orientation == "N" )
        rc = ledValueNorm[sIndex] ","
      else
        rc = ledValueFlip[sIndex] ","
      gsub(/<[0-9][NF][0-9]+>/,rc)
    }

    printf($0 "\n") # the the source, possibly modified
  } # end file text_strings.txt

} # end of pgm


#
# -------------------------------------------------------------------
#
function add_decimal(hexchars)
{
    # hexchars = "0x4F"
    msb = substr(hexchars,3,1)
    lsb = substr(hexchars,4,1)
    val = 0
    if ( msb == "F" ){ val += 240 }
    if ( msb == "E" ){ val += 224 }
    if ( msb == "D" ){ val += 208 }
    if ( msb == "C" ){ val += 192 }
    if ( msb == "B" ){ val += 176 }
    if ( msb == "A" ){ val += 160 }
    if ( msb == "9" ){ val += 144 }
    if ( msb == "8" ){ val += 128 }
    if ( msb == "7" ){ val += 112 }
    if ( msb == "6" ){ val +=  96 }
    if ( msb == "5" ){ val +=  80 }
    if ( msb == "4" ){ val +=  64 }
    if ( msb == "3" ){ val +=  48 }
    if ( msb == "2" ){ val +=  32 }
    if ( msb == "1" ){ val +=  16 }
    if ( lsb == "F" ){ val +=  15 }
    if ( lsb == "E" ){ val +=  14 }
    if ( lsb == "D" ){ val +=  13 }
    if ( lsb == "C" ){ val +=  12 }
    if ( lsb == "B" ){ val +=  11 }
    if ( lsb == "A" ){ val +=  10 }
    if ( lsb == "9" ){ val +=   9 }
    if ( lsb == "8" ){ val +=   8 }
    if ( lsb == "7" ){ val +=   7 }
    if ( lsb == "6" ){ val +=   6 }
    if ( lsb == "5" ){ val +=   5 }
    if ( lsb == "4" ){ val +=   4 }
    if ( lsb == "3" ){ val +=   3 }
    if ( lsb == "2" ){ val +=   2 }
    if ( lsb == "1" ){ val +=   1 }
    if (val >= 128) val -= 128
    return sprintf("0x%02X",val)
}
#
# -------------------------------------------------------------------
#
function hexToString(hexchars)
{
    # hexchars = "0x4F"
    msb = substr(hexchars,3,1)
    lsb = substr(hexchars,4,1)
    val = 0
    if ( msb == "F" ){ val += 240 }
    if ( msb == "E" ){ val += 224 }
    if ( msb == "D" ){ val += 208 }
    if ( msb == "C" ){ val += 192 }
    if ( msb == "B" ){ val += 176 }
    if ( msb == "A" ){ val += 160 }
    if ( msb == "9" ){ val += 144 }
    if ( msb == "8" ){ val += 128 }
    if ( msb == "7" ){ val += 112 }
    if ( msb == "6" ){ val +=  96 }
    if ( msb == "5" ){ val +=  80 }
    if ( msb == "4" ){ val +=  64 }
    if ( msb == "3" ){ val +=  48 }
    if ( msb == "2" ){ val +=  32 }
    if ( msb == "1" ){ val +=  16 }
    if ( lsb == "F" ){ val +=  15 }
    if ( lsb == "E" ){ val +=  14 }
    if ( lsb == "D" ){ val +=  13 }
    if ( lsb == "C" ){ val +=  12 }
    if ( lsb == "B" ){ val +=  11 }
    if ( lsb == "A" ){ val +=  10 }
    if ( lsb == "9" ){ val +=   9 }
    if ( lsb == "8" ){ val +=   8 }
    if ( lsb == "7" ){ val +=   7 }
    if ( lsb == "6" ){ val +=   6 }
    if ( lsb == "5" ){ val +=   5 }
    if ( lsb == "4" ){ val +=   4 }
    if ( lsb == "3" ){ val +=   3 }
    if ( lsb == "2" ){ val +=   2 }
    if ( lsb == "1" ){ val +=   1 }
    return sprintf("%c",val)
}
